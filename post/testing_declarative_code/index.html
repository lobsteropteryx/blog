<!DOCTYPE html>
<html lang="en-us">
<head>
	<title>Testing Declarative Code&middot; Notes from the Lifeboat</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="author" content="Ian Firkin">
	<meta name="description" content="Dim interlocutions">
	
	<meta name="generator" content="Hugo 0.42" />

	<!-- CSS -->
	<link rel="stylesheet" href="https://notesfromthelifeboat.com/css/main.css">
	<link rel="stylesheet" href="https://notesfromthelifeboat.com/css/syntax.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="https://notesfromthelifeboat.com/favicon.ico" type="image/x-icon">

	<!-- RSS -->
	

	<!-- Font Awesome -->
	<link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">

	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/default.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
	<header class="site-header">
	<div class="branding">
		<a href="https://notesfromthelifeboat.com/">
		<img class="avatar" src="https://notesfromthelifeboat.com/img/avatar.png" alt=""/>
		</a>
		<h1 class="site-title">
			<a href="https://notesfromthelifeboat.com/">Notes from the Lifeboat</a>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			<li><a href="/about/"> About </a></li>

			<li class="icon">
	<a href="https://notesfromthelifeboat.com/" title="">
		<i class="fa fa-fw fa-home"></i>
	</a>
</li>

<li class="icon">
	<a href="https://notesfromthelifeboat.com/index.xml" title="Subcribe">
		<i class="fa fa-fw fa-rss"></i>
	</a>
</li>

<li class="icon">
	<a href="mailto:ian.firkin@gmail.com" title="Email">
		<i class="fa fa-fw fa-envelope"></i>
	</a>
</li>











<li class="icon">
	<a href="https://github.com/lobsteropteryx" title="GitHub">
		<i class="fa fa-fw fa-github"></i>
	</a>
</li>



















<li class="icon">
	<a href="https://twitter.com/lobsteropteryx" title="Twitter">
		<i class="fa fa-fw fa-twitter"></i>
	</a>
</li>









		</ul>
	</nav>
</header>


	<div class="content">
	<article>
		<header>
			<h1 class="title">Testing Declarative Code</h1>
			<p class="meta">
	December 17, 2017 &middot; 5 minute read

	
</p>

		</header>

		<section class="post-content">
			

<p>We&rsquo;ve had some interesting discussions on our team recently, about the level of testing required for some very declarative sections of our codebase.  I&rsquo;ve been thinking about this subject a lot, especially after reading a recent <a href="https://www.facebook.com/notes/kent-beck/unit-tests/1726369154062608/">post</a> by Kent Beck.</p>

<p>The fundamental problem we were trying to solve was this:  We have a Python dictionary that represents an entity&ndash;in this case, a person.  All of its values are strings:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s2">&#34;Name&#34;</span><span class="p">:</span> <span class="s2">&#34;Bob&#34;</span><span class="p">,</span>
  <span class="s2">&#34;Age&#34;</span><span class="p">:</span> <span class="s2">&#34;42&#34;</span><span class="p">,</span>
  <span class="s2">&#34;Rate&#34;</span><span class="p">:</span> <span class="s2">&#34;2.345&#34;</span>
<span class="p">}</span></code></pre></div>
<p>Certain keys within the dictionary need their values converted in some way&ndash;for example, <code>&quot;42&quot;</code> should be converted to an <code>int</code>, and <code>&quot;2.345&quot;</code> should be a <code>Decimal</code>, but <code>&quot;Bob&quot;</code> should remain a string.  We might have several of these  dictionaries in a list, but we can assume that all entries in the list have the same schema.</p>

<p>We wanted an abstraction to handle the data transforms that could be extended to handle additional entities; we settled on a solution like the following, using Python&rsquo;s <a href="https://docs.python.org/2/library/collections.html#collections.defaultdict"><code>defaultdict</code></a>:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">person_entities</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="s2">&#34;Name&#34;</span><span class="p">:</span> <span class="s2">&#34;Bob&#34;</span><span class="p">,</span>
        <span class="s2">&#34;Age&#34;</span><span class="p">:</span> <span class="s2">&#34;42&#34;</span><span class="p">,</span>
        <span class="s2">&#34;Rate&#34;</span><span class="p">:</span> <span class="s2">&#34;2.345&#34;</span>
    <span class="p">},</span> 
    <span class="p">{</span>
        <span class="s2">&#34;Name&#34;</span><span class="p">:</span> <span class="s2">&#34;Jane&#34;</span><span class="p">,</span>
        <span class="s2">&#34;Age&#34;</span><span class="p">:</span> <span class="s2">&#34;17&#34;</span><span class="p">,</span>
        <span class="s2">&#34;Rate&#34;</span><span class="p">:</span> <span class="s2">&#34;1.234&#34;</span>
    <span class="p">}</span>
<span class="p">]</span>

<span class="n">PERSON_CONVERTERS</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span>
<span class="n">PERSON_CONVERTERS</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
    <span class="s1">&#39;Age&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="s1">&#39;Rate&#39;</span><span class="p">:</span> <span class="n">Decimal</span>
<span class="p">})</span>

<span class="k">def</span> <span class="nf">transform_data</span><span class="p">(</span><span class="n">entities</span><span class="p">,</span> <span class="n">converters</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">entity</span> <span class="ow">in</span> <span class="n">entities</span><span class="p">:</span>
        <span class="k">yield</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">converters</span><span class="p">[</span><span class="n">key</span><span class="p">](</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">entity</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></code></pre></div>
<p>Essentially this says, &ldquo;If you have a converter defined for the key, apply it to the value; otherwise, just return the value itself.&rdquo;  To handle new entity types, we would define another set of converters specific to that entity.</p>

<p>The question that arose was:  At what level should we test this transformation code?</p>

<p>We already had higher-level acceptance tests in place for each entity, which exercised the transform logic; the discussion centered around the need for lower-level unit or integration tests.  Do we want a test for each transform type (<code>int</code>, <code>Decimal</code>, etc)?  Each entity?  How much behavior is really here, and to what extent are we just testing built-in Python functions?</p>

<h2 id="declarative-code">Declarative Code</h2>

<p>I argued against a test per entity.  Certainly I want <em>some</em> tests around this logic&ndash;I probably want to run each built-in callable through, and any custom functions should have their own tests.  But executing the transform function against every entity doesn&rsquo;t reduce my risk, at least not enough to justify the cost of writing and maintaining those tests.</p>

<p>Suppose I have entities like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="n">entity_one_list</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="s2">&#34;Name&#34;</span><span class="p">:</span> <span class="s2">&#34;Bob&#34;</span><span class="p">,</span>
        <span class="s2">&#34;Age&#34;</span><span class="p">:</span> <span class="s2">&#34;42&#34;</span><span class="p">,</span>
    <span class="p">},</span> 
    <span class="p">{</span>
        <span class="s2">&#34;Name&#34;</span><span class="p">:</span> <span class="s2">&#34;Jane&#34;</span><span class="p">,</span>
        <span class="s2">&#34;Age&#34;</span><span class="p">:</span> <span class="s2">&#34;17&#34;</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">]</span>

<span class="n">ENTITY_ONE_CONVERTERS</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span>
<span class="n">ENTITY_ONE_CONVERTERS</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
    <span class="s1">&#39;Age&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">})</span>

<span class="n">entity_two_list</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="s2">&#34;FirstName&#34;</span><span class="p">:</span> <span class="s2">&#34;Billy&#34;</span><span class="p">,</span>
        <span class="s2">&#34;LastName&#34;</span><span class="p">:</span> <span class="s2">&#34;Bob&#34;</span><span class="p">,</span>
        <span class="s2">&#34;NumberOfCats&#34;</span><span class="p">:</span> <span class="s2">&#34;3&#34;</span><span class="p">,</span>
    <span class="p">},</span> 
    <span class="p">{</span>
        <span class="s2">&#34;FirstName&#34;</span><span class="p">:</span> <span class="s2">&#34;Jane&#34;</span><span class="p">,</span>
        <span class="s2">&#34;LastName&#34;</span><span class="p">:</span> <span class="s2">&#34;Doe&#34;</span><span class="p">,</span>
        <span class="s2">&#34;NumberOfCats&#34;</span><span class="p">:</span> <span class="s2">&#34;0&#34;</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">]</span>

<span class="n">ENTITY_TWO_CONVERTERS</span><span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span>
<span class="n">ENTITY_TWO_CONVERTERS</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
    <span class="s1">&#39;NumberOfCats&#39;</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">})</span></code></pre></div>
<p>What am I actually verifying by putting a test around each entity?  Only that I&rsquo;ve built the transform dictionaries correctly.  I could write that test more explicitly:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">ENTITY_ONE_CONVERSIONS</span> <span class="nn">from</span> <span class="nn">somewhere</span>

<span class="n">test_entity_one_conversions_are_correct</span><span class="p">():</span>

    <span class="n">expected</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">expected</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
        <span class="s1">&#39;Age&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">})</span>
    
    <span class="k">assert</span> <span class="n">ENTITY_ONE_CONVERSIONS</span> <span class="o">==</span> <span class="n">expected</span></code></pre></div>
<p>But that&rsquo;s the very definition of a implementation test, which isn&rsquo;t surprising&ndash;there is no behavior here to test.</p>

<h2 id="abstraction-functions-and-data-structures">Abstraction, Functions, and Data Structures</h2>

<p>We started off trying to abstract our data transformation, and  what we ended up with is a single function with arity 2, and the data structures that it takes as arguments.  Like any other piece of logic, I want to test the edge cases, and I&rsquo;m not interested in writing tests that capture every possible combination of arguments.  It&rsquo;s easier to see this with a simpler transform:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span></code></pre></div>
<p>What tests would I want around this code?  Assuming that <code>a</code> and <code>b</code> are integers, I probably want a test to capture the <a href="https://en.wikipedia.org/wiki/Additive_identity">identity</a> operation, and a handful of other cases&ndash;two positive numbers, two negatives, a positive and a negative, etc.</p>

<p>This is really the definition of abstractions&ndash;that we can logically reason about behavior without having to examine each and every case.</p>

<h2 id="test-pyramid">Test Pyramid</h2>

<p>One of the concerns that was raised was that we were violating the concept of the <a href="https://martinfowler.com/bliki/TestPyramid.html">Test Pyramid</a>; there was a desire to have additional integration tests in place, at a lower level than our acceptance tests.</p>

<p>In general, I view integration tests as a <em>sometimes</em> necessary evil, and I want as few of them as possible; certainly I don&rsquo;t want to test each and every combination of modules.  Every additional level of integration tests I write is another place I may have to make changes in the future&ndash;so those tests need to <em>significantly</em> reduce risk or iteration time in order to pay for themselves.</p>

<p>For us, the system in question was a CLI tool that inserts records to a local database, and is made up of three python modules.  Our top-level acceptance tests verify the full behavior for each entity, and the entire test suite runs locally in about 20 seconds.</p>

<p>That&rsquo;s not a system that makes me want another level of integration tests&ndash;to me, the benefits just don&rsquo;t outweigh the costs.  If you look at Martin Fowler&rsquo;s original article, many of the scenarios that he outlines just don&rsquo;t apply, and he even adds a footnote:</p>

<blockquote>
<p>The pyramid is based on the assumption that broad-stack tests are expensive, slow, and brittle compared to more focused tests, such as unit tests. While this is usually true, there are exceptions. If my high level tests are fast, reliable, and cheap to modify - then lower-level tests aren&rsquo;t needed.</p>
</blockquote>

<p>I believe that treating the test pyramid as something that must be religiously followed is a mistake; the context matters immensely, and I would argue that many simple systems don&rsquo;t need three tiers of tests.</p>

<p>From the Lean point of view, tests are a necessary waste, and they surely have a cost.  If I&rsquo;m satisfied with my suite of top-level acceptance tests, I don&rsquo;t think it makes sense to write additional integration tests just so that I can say that my test suite is pyramid shaped.</p>


			
				<div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "notesfromthelifeboat" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
			
		</section>
	</article>
	</div>

	<footer class="site-footer">
	<p class="text">&copy; 2020 - Released under the MIT license<br>Powered by <a href="//gohugo.io/">Hugo</a> with the <a href="//github.com/digitalcraftsman/hugo-type-theme">Type Theme</a></p>
</footer>


<script>
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-27980065-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</body>
</html>
